---
title: "Spatial visualization for multiplexed imaging cytometry data in R"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('cytomapper')`"
author:
- name: Nils Eling
  affiliation: Department for Quantitative Biomedicine, University of Zurich
  email: nils.eling@dqbm.uzh.ch.com
- name: Nicolas Damond
  affiliation: Department for Quantitative Biomedicine, University of Zurich
  email: nicolas.damond@dqbm.uzh.ch.com
output:
  BiocStyle::html_document:
    toc_float: yes
bibliography: library.bib
abstract: |
    Highly multiplexed imaging cytometry acquires the single-cell expression of
    selected proteins in a spatially-resolved fashion. These measurements can be
    visualized across multiple length-scales. First, pixel-level intensities
    represent the spatial distributions of feature expression with highest
    resolution. Second, after segmentation, expression values or cell-level
    metadata (e.g. cell-type information) can be visualized on segmented cell
    areas. This package contains functions for the visualization of multiplexed
    read-outs and cell-level information obtained by multiplexed imaging
    cytometry. The main functions of this package allow 1. the visualization of
    pixel-level information across multiple channels and 2. the display of
    cell-level information (expression and/or metadata) on segmentation masks.
vignette: |
  %\VignetteIndexEntry{Spatial visualization for multiplexed imaging cytometry data in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(error=FALSE, warning=FALSE, message=FALSE)
library(BiocStyle)
```

```{r library, echo=FALSE}
library(cytomapper)
```

# Introduction

This vignette gives an introduction to displaying highly multiplexed imaging cytometry data with the `cytomapper` package.
As an example, these instructions display imaging mass cytometry (IMC) data.
However, other imaging cytometry approaches including multiplexed ion beam imaging (MIBI) [@angelo2014mibi], tissue-based cyclic immunofluorescence (t-CyCIF) [@lin2018cycif] and iterative indirect immunofluorescence imaging (4i) [@gut20184i], which produce pixel-level intensities and optionally segmentation masks can be displayed using `cytomapper`.

IMC [@giesen2014imc] is a multiplexed imaging approach to measure spatial protein abundance.
In IMC, tissue sections are stained with a mix of $\tilde{}40$ metal-conjugated antibodies prior to laser ablation with $1\mu{}m$ resolution. 
The ablated material is transferred to a mass cytometer for time-of-flight detection of the metal ions [@giesen2014imc][@mavropoulosimc]. 
In that way, hundreds of images (usually with an image size of around 1mm x 1mm) can be generated in a reasonable amount of time [@damond2019pancreas]. 

Raw IMC data are computationally processed using a segmentation pipeline (available at [https://github.com/BodenmillerGroup/ImcSegmentationPipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline)). 
This pipeline produces image stacks containing the raw pixel values for up to 40 channels, segmentation masks containing the segmented cells, cell-level expression and metadata information as well as a number of image-level meta information.

Cell-level expression and metadata can be processed and read into a `SingleCellExperiment` class object.
For more information on the `SingleCellExperiment` object and how to create it, please see the `r Biocpkg("SingleCellExperiment")` package and the [Orchestrating Single-Cell Analysis with Bioconductor](https://osca.bioconductor.org/data-infrastructure.html#the-singlecellexperiment-class) workflow.

The `cytomapper` package provides a new `CytoImageList` class as a container for multiplexed images or segmentation masks.
For more information on this class, refer to the [CytoImageList](#CytoImageList) section.

The main functions of this package include `plotCells` and `plotPixels`.
The `plotCells` function requires the following object inputs to display cell-level information (expression and metadata):

1. a SingleCellExperiment object, which contains the cells' counts and metadata
2. an CytoImageList object containing the segmentation mask per image

The `plotPixels` function requires the following object inputs to display pixel-level expression information:

1. a `CytoImageList` object containing the pixel-level information per channel
2. (optionally) a `SingleCellExperiment` object, which contains the cells' counts and metadata
2. (optionally) a `CytoImageList` object containing the segmentation mask per image

# Quick start

The following section provides a quick example highlighting the functionality of `cytomapper`.
For detailed information on reading in the data, refer to the [Reading in data](#ReadingData) section.
More information on the required data format is provided in the [Data formats](#DataFormats) section.
In the first step, we will read in the provided [toy dataset](#ToyData)

```{r quickstart-load-data}
data(pancreasSCE)
data(pancreasImages)
data(pancreasMasks)
```

The `CytomImageList` object containing pixel-level intensities representing the ion counts for five proteins can be displayed using the `plotPixel` function:

```{r quickstart-plotPixels}
plotPixels(image = pancreasImages, colour_by = c("H3", "SMA", "CD44"))
```

For more details on image normalization, cell outlining, and other pixel-level manipulations, refer to the [Plotting pixel information](#PixelInfo) section.

The `CytoImageList` object containing segmentation masks that represent the cell areas on the image can be displayed using the `plotCells` function.
Only the segmentation masks are plotted when no other parameters are specified.

```{r quickstart-plotCells}
plotCells(mask = pancreasMasks)
```

To colour and/or outline segmentation masks, a `SingleCellExperiment`, an `img_id` and `cell_id` entry need to be specified:

```{r quickstart-plotCells-2}
plotCells(mask = pancreasMasks, object = pancreasSCE, cell_id = "CellNb", img_id = "ImageNb", colour_by = "SMA")
plotCells(mask = pancreasMasks, object = pancreasSCE, cell_id = "CellNb", img_id = "ImageNb", colour_by = "SMA", outline_by = "CellType")
plotCells(mask = pancreasMasks, object = pancreasSCE, cell_id = "CellNb", img_id = "ImageNb", colour_by = "CellType")
```

For more information on the data formats and requirements, refer to the following section.
More details on the `plotCells` function are provided in the [Plotting cell information](#CellInfo) section.

# Data formats {#DataFormats}

The `cytomapper` package combines objects of the `r Biocpkg("SingleCellExperiment")` class and the `CytoImageList` class (provided in `cytomapper`) to visualize cell- and pixel-level information.

In the main functions of the package, `image` refers to an `CytoImageList` object containing one or multiple multi-channel images where each channel represents the pixel-intensity of one selected marker (proteins in the case of IMC).
The entry `mask` refers to an `CytoImageList` object containing one or multiple segmentation masks.
Segmentation masks are defined as one-channel images containing integer values, which represent the cells' ids or 0 (background).
Finally, the `object` entry refers to a `SingleCellExperiment` class object that contains cell-specific expression values (in the `assay` slots) and cell-specific metadata in the `colData` slot.

To link information between the `SingleCellExperiment` and `CytoImageList` objects, two slots need to be specified:

* `img_id`: a single character indicating the `colData` (in the `SingleCellExperiment` object) and `elementMetadata` (in the `CytoImageList` object) entry that contains the image identifiers. These image ids have to match between the `SingleCellExperiment` object and the `CytoImageList` object.
* `cell_id`: a single character indicating the `colData` entry that contains the cell identifiers. These should be integer values corresponing to pixel-values in the segmentation masks.

The `img_id` and `cell_id` entry in the `SingleCellExperiment` object need to be accessible via: 

```{r image-cell-id-sce}
colData(pancreasSCE)[,"ImageNb"]
colData(pancreasSCE)[,"CellNb"]
```

The `img_id` entry in the `CytoImageList` object need to be accessible via: 

```{r image-cell-id-cil}
mcols(pancreasImages)[,"ImageNb"]
mcols(pancreasMasks)[,"ImageNb"]
```

For more information on the `CytoImageList` class, please refer to the section [The CytoImageList object](#CytoImageList).
For more information on the `SingleCellExperiment` object and how to create it, please see the `r Biocpkg("SingleCellExperiment")` package and the [Orchestrating Single-Cell Analysis with Bioconductor](https://osca.bioconductor.org/data-infrastructure.html#the-singlecellexperiment-class) workflow.

## The provided toy dataset {#ToyData}

For visualization purposes, the `cytomapper` package provides a toy dataset containing 3 images of $100\mu{m}$ x $100\mu{m}$ dimensions (100 x 100 pixels).
The dataset contains 282 segmented cells and the expression values for 5 proteins: H3, SMA, INS, CD38, and CD44
It represents a small subset of the data presented in [A Map of Human Type 1 Diabetes Progression by Imaging Mass Cytometry](Ahttps://www.cell.com/cell-metabolism/fulltext/S1550-4131(18)30691-0?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1550413118306910%3Fshowall%3Dtrue).

Pixel-level intensities for all 5 markers (5 channels) are stored in the `pancreasImages` object.
Entires to the `CytoImageList` object and the rownames of the object match: A02_imc, D01_imc, and F01_imc
The `elementMetadata` slot (accesible via the `mcols()` function) contains the image identifiers.

```{r pancreasImages}
pancreasImages
mcols(pancreasImages)
channelNames(pancreasImages)
imageData(pancreasImages[[1]])[1:15,1:5,1]
```

The corresponding segmentation masks are stored in the `pancreasMasks` object.
Segmentation masks are defined as one-channel images containing integer values, which represent the cells' ids or 0 (background).

```{r pancreasMasks}
pancreasMasks
mcols(pancreasMasks)
imageData(pancreasMasks[[1]])[1:15,1:5]
```

All cell-specific metadata are stored in the `colData` slot of the corresponding `SingleCellExperiment` object: `pancreasSCE`.
For more information on the metadata, please refer to the `?pancreasSCE` documentation.
Of note: the cell-type labels contained in the `colData(pancreasSCE)$CellType` slot are randomized and do not represent biologically relevant cell-types.

```{r pancreasSCE}
pancreasSCE
names(colData(pancreasSCE))
```

The `pancreasSCE` object also contains further information on the measured proteins via the `rowData(pancreasSCE)` slot.
Furthermore, the `pancreasSCE` object contains the raw expression counts per cell in the form of mean pixel value per cell and protein (accessible via `counts(pancreasSCE)`).
The arcsinh-transformed (using a co-factor of 1) raw expression counts can be obtained via `assay(pancreasSCE, "exprs")`.

# Reading in data {#ReadingData}

The `cytomapper` package provides the `loadImages` function to conveniently read images into a `CytoImageList` object.

## Load images

The `loadImages` function returns a `CytoImageList` object containing the multi-channel images or segmentation masks.
Refer to the `?loadImages` function to see the full functionality.

As an example, we will read in multi-channel images and segmentation masks provided by the `cytomapper` package.

```{r read-in-images}
# Read in masks
path.to.images <- system.file("extdata", package = "cytomapper")
all_masks <- loadImages(path.to.images, pattern = "_mask.tiff")
all_masks

# Read in images
all_stacks <- loadImages(path.to.images, pattern = "_imc.tiff")
all_stacks
```

## Add metadata

To link images between the two `CytoImageList` objects and the corresponding `SingleCellExperiment` object, the image ids need to be added to the `elementMetadata` slot of the `CytoImageList` objects.
From the experimental setup, we know that the image named 'A02_imc' has image id '1', D01_imc has id '2', F01_imc has id '3'.

```{r add-metadata}
unique(pancreasSCE$ImageNb)
mcols(all_masks)$ImageNb <- c("1", "2", "3")
mcols(all_stacks)$ImageNb <- c("1", "2", "3")
```

## Scale images

We can see, that in some cases, the pixel-values are not correctly scaled by the image encoding.
The segmentation masks should only contain integer entries:

```{r image-encoding}
unique(as.numeric(all_masks[[1]]))
```

The provided data was processed using CellProfiler [@carpenter2006cellprofiler].
By default, CellProfiler scales all pixel intensities between 0 and 1. 
This is done by dividing each count by the maximum possible intensity value (see [MeasureObjectIntensity](https://cellprofiler-manual.s3.amazonaws.com/CellProfiler-3.0.0/modules/measurement.html#measureobjectintensity) for more info). 
In the case of 16-bit encoding (where 0 is a valid intensity), this scaling value is `2^16-1 = 65535`. 
Therefore, pixel-intensites need to be rescaled by this value.
However, this scaling value can change and different images can be scaled by different factors.
The user needs make sure to select the correct factors in more complex cases.

The `cytopmapper` package provides a `?scaleImages` function.
The user needs to manually scale images to obtain the correct pixel-values.
Here, we scale the segmentation masks by the factor for 16-bit encoding: `2^16-1`

```{r scaleImage-1}
all_masks <- scaleImages(all_masks, 2^16-1)
unique(as.numeric(all_masks[[1]]))
```

In this case, the multi-channel images are not affected by this scaling factor.

## Add channel names

To access the correct images in the multi-channel `CytoImageList` object, the user needs to set the correct channel names.
For this, the `cytomapper` package provides the `?channelNames` getter and setter function:

```{r channelNames-example}
channelNames(all_stacks) <- c("H3", "SMA", "INS", "CD38", "CD44")
```

The read-in data can now be used for visualization:

```{r example-viz}
plotPixels(all_stacks, colour_by = c("H3", "SMA", "CD44"))
plotCells(all_masks, object = pancreasSCE, cell_id = "CellNb", img_id = "ImageNb", colour_by = "CellType")
```

# The CytoImageList object {#CytoImageList}

The `cytomapper` package provides a new `CytoImageList` class, which inherits from the [`SimpleList` class](https://rdrr.io/bioc/S4Vectors/man/SimpleList-class.html).
Each entry to the `CytoImageList` object is an `Image` class object defined in the `r BiocStyle::Biocpkg("EBImage")` package.
A `CytoImageList` object is restricted to the following entries:

* all images need to have the same number of channels
* the order/naming of channels need to be the same across all images
* entries to the `CytoImageList` object need to be uniquely named
* names of `CytoImageList` object can either be `NULL` or should not contain `NA` or empty entries
* only grayscale images are supported (see `?Image` for more information)
* channels names do not support duplicated entries

`CytoImageList` objects that contain masks should only contain a single channel

The follwoing paragraphs will explain further details on manipulating `CytoImageList` objects

## Accessors

All accessor functions defined for `SimpleList` also work on `CytoImageList` class objects.
Element-wise metadata --- in the case of the `CytoImageList` object these are image-specific metadata --- are saved in the `elementMetadata` slot. 
This slot can be accessed via the `mcols()` function:

```{r mcols}
mcols(pancreasImages)
mcols(pancreasImages)$PatientID <- c("Patient1", "Patient2", "Patient3")
mcols(pancreasImages)
```
Subsetting a `CytoImageList` object works similar to a `SimpleList` object:

```{r subsetting}
pancreasImages[1]
pancreasImages[[1]]
```

However, to facilitate subsetting and making sure that entry names are transfered between objects, the `cytomapper` package provides a number of getter and setter functions:

### Getting and setting images

Individual or multiple entries in a `CytoImageList` object can be obtained or replaced using the `getImages` and `setImages` function respectively.

```{r get-set-images}
cur_image <- getImages(pancreasImages, "A02_imc")
cur_image
setImages(pancreasImages, "New_image") <- cur_image
pancreasImages
mcols(pancreasImages)
```

The `setImages` function ensures that names are transfered from one to the other object along the assignment operator:

```{r set-images}
names(cur_image) <- "Replacement"
setImages(pancreasImages, 2) <- cur_image
pancreasImages
mcols(pancreasImages)
```

However, if the image to replace is called by name, only the image and associated metadata is replaced:

```{r set-images-2}
setImages(pancreasImages, "F01_imc") <- cur_image
pancreasImages
mcols(pancreasImages)
```

Images can be deleted by setting the entry to `NULL`:

```{r deleting-images}
setImages(pancreasImages, c("Replacement", "New_image")) <- NULL
pancreasImages
```

**Of note:** for plotting, the entries in the `img_id` slot in the `CytoImageList` objects have to be unique.

### Getting and setting channels

The `cytomapper` package also provides functions to obtain and replace channels. 
This functionality is provided via the `getChannels` and `setChannels` functions:

```{r get-set-channels}
cur_channel <- getChannels(pancreasImages, "H3")
cur_channel
channelNames(cur_channel) <- "New_H3"
setChannels(pancreasImages, 1) <- cur_channel
pancreasImages
```

The `setChannels` function does not allow combining and adding new channels.
For this task, the `cytomapper` package provides the `mergeChannels` section in the next paragraph.

### Naming and merging channels

Channel names can be obtained and replaced using the `channelNames` getter and setter function:

```{r channelnames}
channelNames(pancreasImages)
channelNames(pancreasImages) <- c("ch1", "ch2", "ch3", "ch4", "ch5")
pancreasImages
```

Furthermore, channels can be merged using the `mergeChannels` function:

```{r mergechannels}
cur_channels <- getChannels(pancreasImages, 1:2)
channelNames(cur_channels) <- c("new_ch1", "new_ch2")
pancreasImages <- mergeChannels(pancreasImages, cur_channels) 
pancreasImages
```

## Looping

To perform custom operations on each individual entry to a `CytoImageList` object, the `r Biocpkg("S4Vectors")` package provides the `endoapply` function.
While the `lapply` function returns a `list` object, the `endoapply` function provides an object of the same class of the input object.

This allows the user to apply all functions provided by the `r Biocpkg("EBImage")` package to individual entries within the `CytoImageList` object:

```{r endoapply-example}
data("pancreasImages")

# Performing a gaussian blur
pancreasImages <- endoapply(pancreasImages, gblur, sigma = 1)

plotPixels(pancreasImages, colour_by = c("H3", "SMA", "CD44"))
```

# Plotting pixel information {#PixelInfo}

The `cytomapper` package provides the `plotPixels` function to plot pixel-level intensities of marker proteins.
The function requires a `CytoImageList` object containing a single or multiple multi-channel images.
To colour images based on channel name, the `channelNames` of the object need to be set.
Furthermore, to outline images, a `CytoImageList` object containing segmentation masks and a `SingleCellExperiment` object containing cell-specific metadata need to be provided.

By default, pixel values are coloured internally and scaled between the minimum and maximum values across all displayed images.
However, to manipulate pixel values and to linearly scale values to a certain range, the `cytomapper` package provides a function for image normalization.

## Normalization

The `normalize` function provided in the `cytomapper` package internally calls the `normalize` function of the `EBImage` package.
The main difference between the two functions is the option to scale per image or globally in the `cytomapper` package.
Furthermore, the `cytomapper` package `normalize` function (see `?'normalize,CytoImageList-method'`) allows the user to define a clipping range based on percentiles.

By default, the `normalize` function linearly scales the images channel-wise across all images and returns values between 0 and 1:

```{r normalize-default}
data("pancreasImages")

# Default normalization
cur_images <- normalize(pancreasImages)

plotPixels(cur_images, colour_by = c("H3", "SMA", "CD44"))
```

A `CytoImageList` object can also be normalized image-wise:

```{r normalize-image-wise}
# Image-wise normalization
cur_images <- normalize(pancreasImages, separateImages = TRUE)

plotPixels(cur_images, colour_by = c("H3", "SMA", "CD44"))
```

To clip the image range, the user can provide a percentage-based clipping range:

```{r normalize-clippingrange}
# Percentage-based clipping range
cur_images <- normalize(pancreasImages, percentileRange = c(0,0.99))
plotPixels(cur_images, colour_by = c("H3", "SMA", "CD44"))
```

For more information on the normalization functionality provided by the `cytomapper` package, please refer to `?'normalize,CytoImageList-method'`.

## Colouring

## Adjusting brightness, contrast and gamma

## Outlining

## Subsetting

## Adjusting the colour

# Plotting cell information {#CellInfo}

## Colouring

## Outlining

## Changeing the assay slot

## Subsetting

## Adjusting the colour

# Customization

## Legend

## Scale bar

Per pixel - user needs to know what 1 pixel is...

## Scale

```{r}
cur_images <- normalize(pancreasImages, inputRange = c(0,120), percentileRange = NULL)
plotPixels(cur_images, colour_by = c("H3", "SMA", "CD44"), scale = FALSE)
```

# Saving images

# Acknowledgements

# Contributions

Nicolas created cytomapper - Nicolas and Nils implemented the package ...

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References

